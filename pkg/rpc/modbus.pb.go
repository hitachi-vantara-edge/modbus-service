// Code generated by protoc-gen-go. DO NOT EDIT.
// source: modbus.proto

package modbus

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type ConnectionStatusReply_Type int32

const (
	ConnectionStatusReply_TCP    ConnectionStatusReply_Type = 0
	ConnectionStatusReply_SERIAL ConnectionStatusReply_Type = 1
)

var ConnectionStatusReply_Type_name = map[int32]string{
	0: "TCP",
	1: "SERIAL",
}
var ConnectionStatusReply_Type_value = map[string]int32{
	"TCP":    0,
	"SERIAL": 1,
}

func (x ConnectionStatusReply_Type) String() string {
	return proto.EnumName(ConnectionStatusReply_Type_name, int32(x))
}
func (ConnectionStatusReply_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_modbus_a63a6c6fc050268c, []int{8, 0}
}

type ConnectionStatusReply_Status int32

const (
	ConnectionStatusReply_ERROR   ConnectionStatusReply_Status = 0
	ConnectionStatusReply_CLOSED  ConnectionStatusReply_Status = 1
	ConnectionStatusReply_PENDING ConnectionStatusReply_Status = 2
	ConnectionStatusReply_UNKNOWN ConnectionStatusReply_Status = 3
	ConnectionStatusReply_READY   ConnectionStatusReply_Status = 4
)

var ConnectionStatusReply_Status_name = map[int32]string{
	0: "ERROR",
	1: "CLOSED",
	2: "PENDING",
	3: "UNKNOWN",
	4: "READY",
}
var ConnectionStatusReply_Status_value = map[string]int32{
	"ERROR":   0,
	"CLOSED":  1,
	"PENDING": 2,
	"UNKNOWN": 3,
	"READY":   4,
}

func (x ConnectionStatusReply_Status) String() string {
	return proto.EnumName(ConnectionStatusReply_Status_name, int32(x))
}
func (ConnectionStatusReply_Status) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_modbus_a63a6c6fc050268c, []int{8, 1}
}

type ReadHoldingRegRequest struct {
	SlaveAddr            uint32   `protobuf:"varint,1,opt,name=slave_addr,json=slaveAddr,proto3" json:"slave_addr,omitempty"`
	StartAddr            uint32   `protobuf:"varint,2,opt,name=start_addr,json=startAddr,proto3" json:"start_addr,omitempty"`
	NumOfReg             uint32   `protobuf:"varint,3,opt,name=num_of_reg,json=numOfReg,proto3" json:"num_of_reg,omitempty"`
	ReadInput            bool     `protobuf:"varint,4,opt,name=read_input,json=readInput,proto3" json:"read_input,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ReadHoldingRegRequest) Reset()         { *m = ReadHoldingRegRequest{} }
func (m *ReadHoldingRegRequest) String() string { return proto.CompactTextString(m) }
func (*ReadHoldingRegRequest) ProtoMessage()    {}
func (*ReadHoldingRegRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_modbus_a63a6c6fc050268c, []int{0}
}
func (m *ReadHoldingRegRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ReadHoldingRegRequest.Unmarshal(m, b)
}
func (m *ReadHoldingRegRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ReadHoldingRegRequest.Marshal(b, m, deterministic)
}
func (dst *ReadHoldingRegRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReadHoldingRegRequest.Merge(dst, src)
}
func (m *ReadHoldingRegRequest) XXX_Size() int {
	return xxx_messageInfo_ReadHoldingRegRequest.Size(m)
}
func (m *ReadHoldingRegRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ReadHoldingRegRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ReadHoldingRegRequest proto.InternalMessageInfo

func (m *ReadHoldingRegRequest) GetSlaveAddr() uint32 {
	if m != nil {
		return m.SlaveAddr
	}
	return 0
}

func (m *ReadHoldingRegRequest) GetStartAddr() uint32 {
	if m != nil {
		return m.StartAddr
	}
	return 0
}

func (m *ReadHoldingRegRequest) GetNumOfReg() uint32 {
	if m != nil {
		return m.NumOfReg
	}
	return 0
}

func (m *ReadHoldingRegRequest) GetReadInput() bool {
	if m != nil {
		return m.ReadInput
	}
	return false
}

type ReadHoldingRegReply struct {
	ByteCount            uint32                                      `protobuf:"varint,1,opt,name=byte_count,json=byteCount,proto3" json:"byte_count,omitempty"`
	IsInput              bool                                        `protobuf:"varint,2,opt,name=is_input,json=isInput,proto3" json:"is_input,omitempty"`
	Values               []*ReadHoldingRegReply_HoldingRegisterValue `protobuf:"bytes,3,rep,name=values,proto3" json:"values,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                    `json:"-"`
	XXX_unrecognized     []byte                                      `json:"-"`
	XXX_sizecache        int32                                       `json:"-"`
}

func (m *ReadHoldingRegReply) Reset()         { *m = ReadHoldingRegReply{} }
func (m *ReadHoldingRegReply) String() string { return proto.CompactTextString(m) }
func (*ReadHoldingRegReply) ProtoMessage()    {}
func (*ReadHoldingRegReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_modbus_a63a6c6fc050268c, []int{1}
}
func (m *ReadHoldingRegReply) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ReadHoldingRegReply.Unmarshal(m, b)
}
func (m *ReadHoldingRegReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ReadHoldingRegReply.Marshal(b, m, deterministic)
}
func (dst *ReadHoldingRegReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReadHoldingRegReply.Merge(dst, src)
}
func (m *ReadHoldingRegReply) XXX_Size() int {
	return xxx_messageInfo_ReadHoldingRegReply.Size(m)
}
func (m *ReadHoldingRegReply) XXX_DiscardUnknown() {
	xxx_messageInfo_ReadHoldingRegReply.DiscardUnknown(m)
}

var xxx_messageInfo_ReadHoldingRegReply proto.InternalMessageInfo

func (m *ReadHoldingRegReply) GetByteCount() uint32 {
	if m != nil {
		return m.ByteCount
	}
	return 0
}

func (m *ReadHoldingRegReply) GetIsInput() bool {
	if m != nil {
		return m.IsInput
	}
	return false
}

func (m *ReadHoldingRegReply) GetValues() []*ReadHoldingRegReply_HoldingRegisterValue {
	if m != nil {
		return m.Values
	}
	return nil
}

type ReadHoldingRegReply_HoldingRegisterValue struct {
	Addr                 uint32   `protobuf:"varint,1,opt,name=addr,proto3" json:"addr,omitempty"`
	Value                string   `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ReadHoldingRegReply_HoldingRegisterValue) Reset() {
	*m = ReadHoldingRegReply_HoldingRegisterValue{}
}
func (m *ReadHoldingRegReply_HoldingRegisterValue) String() string { return proto.CompactTextString(m) }
func (*ReadHoldingRegReply_HoldingRegisterValue) ProtoMessage()    {}
func (*ReadHoldingRegReply_HoldingRegisterValue) Descriptor() ([]byte, []int) {
	return fileDescriptor_modbus_a63a6c6fc050268c, []int{1, 0}
}
func (m *ReadHoldingRegReply_HoldingRegisterValue) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ReadHoldingRegReply_HoldingRegisterValue.Unmarshal(m, b)
}
func (m *ReadHoldingRegReply_HoldingRegisterValue) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ReadHoldingRegReply_HoldingRegisterValue.Marshal(b, m, deterministic)
}
func (dst *ReadHoldingRegReply_HoldingRegisterValue) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReadHoldingRegReply_HoldingRegisterValue.Merge(dst, src)
}
func (m *ReadHoldingRegReply_HoldingRegisterValue) XXX_Size() int {
	return xxx_messageInfo_ReadHoldingRegReply_HoldingRegisterValue.Size(m)
}
func (m *ReadHoldingRegReply_HoldingRegisterValue) XXX_DiscardUnknown() {
	xxx_messageInfo_ReadHoldingRegReply_HoldingRegisterValue.DiscardUnknown(m)
}

var xxx_messageInfo_ReadHoldingRegReply_HoldingRegisterValue proto.InternalMessageInfo

func (m *ReadHoldingRegReply_HoldingRegisterValue) GetAddr() uint32 {
	if m != nil {
		return m.Addr
	}
	return 0
}

func (m *ReadHoldingRegReply_HoldingRegisterValue) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

type ReadCoilRequest struct {
	SlaveAddr            uint32   `protobuf:"varint,1,opt,name=slave_addr,json=slaveAddr,proto3" json:"slave_addr,omitempty"`
	StartAddr            uint32   `protobuf:"varint,2,opt,name=start_addr,json=startAddr,proto3" json:"start_addr,omitempty"`
	NumOfCoil            uint32   `protobuf:"varint,3,opt,name=num_of_coil,json=numOfCoil,proto3" json:"num_of_coil,omitempty"`
	ReadInput            bool     `protobuf:"varint,4,opt,name=read_input,json=readInput,proto3" json:"read_input,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ReadCoilRequest) Reset()         { *m = ReadCoilRequest{} }
func (m *ReadCoilRequest) String() string { return proto.CompactTextString(m) }
func (*ReadCoilRequest) ProtoMessage()    {}
func (*ReadCoilRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_modbus_a63a6c6fc050268c, []int{2}
}
func (m *ReadCoilRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ReadCoilRequest.Unmarshal(m, b)
}
func (m *ReadCoilRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ReadCoilRequest.Marshal(b, m, deterministic)
}
func (dst *ReadCoilRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReadCoilRequest.Merge(dst, src)
}
func (m *ReadCoilRequest) XXX_Size() int {
	return xxx_messageInfo_ReadCoilRequest.Size(m)
}
func (m *ReadCoilRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ReadCoilRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ReadCoilRequest proto.InternalMessageInfo

func (m *ReadCoilRequest) GetSlaveAddr() uint32 {
	if m != nil {
		return m.SlaveAddr
	}
	return 0
}

func (m *ReadCoilRequest) GetStartAddr() uint32 {
	if m != nil {
		return m.StartAddr
	}
	return 0
}

func (m *ReadCoilRequest) GetNumOfCoil() uint32 {
	if m != nil {
		return m.NumOfCoil
	}
	return 0
}

func (m *ReadCoilRequest) GetReadInput() bool {
	if m != nil {
		return m.ReadInput
	}
	return false
}

type ReadCoilReply struct {
	BitCount             uint32                     `protobuf:"varint,1,opt,name=bit_count,json=bitCount,proto3" json:"bit_count,omitempty"`
	IsInput              bool                       `protobuf:"varint,2,opt,name=is_input,json=isInput,proto3" json:"is_input,omitempty"`
	Values               []*ReadCoilReply_CoilValue `protobuf:"bytes,3,rep,name=values,proto3" json:"values,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                   `json:"-"`
	XXX_unrecognized     []byte                     `json:"-"`
	XXX_sizecache        int32                      `json:"-"`
}

func (m *ReadCoilReply) Reset()         { *m = ReadCoilReply{} }
func (m *ReadCoilReply) String() string { return proto.CompactTextString(m) }
func (*ReadCoilReply) ProtoMessage()    {}
func (*ReadCoilReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_modbus_a63a6c6fc050268c, []int{3}
}
func (m *ReadCoilReply) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ReadCoilReply.Unmarshal(m, b)
}
func (m *ReadCoilReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ReadCoilReply.Marshal(b, m, deterministic)
}
func (dst *ReadCoilReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReadCoilReply.Merge(dst, src)
}
func (m *ReadCoilReply) XXX_Size() int {
	return xxx_messageInfo_ReadCoilReply.Size(m)
}
func (m *ReadCoilReply) XXX_DiscardUnknown() {
	xxx_messageInfo_ReadCoilReply.DiscardUnknown(m)
}

var xxx_messageInfo_ReadCoilReply proto.InternalMessageInfo

func (m *ReadCoilReply) GetBitCount() uint32 {
	if m != nil {
		return m.BitCount
	}
	return 0
}

func (m *ReadCoilReply) GetIsInput() bool {
	if m != nil {
		return m.IsInput
	}
	return false
}

func (m *ReadCoilReply) GetValues() []*ReadCoilReply_CoilValue {
	if m != nil {
		return m.Values
	}
	return nil
}

type ReadCoilReply_CoilValue struct {
	Addr                 uint32   `protobuf:"varint,1,opt,name=addr,proto3" json:"addr,omitempty"`
	Value                string   `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ReadCoilReply_CoilValue) Reset()         { *m = ReadCoilReply_CoilValue{} }
func (m *ReadCoilReply_CoilValue) String() string { return proto.CompactTextString(m) }
func (*ReadCoilReply_CoilValue) ProtoMessage()    {}
func (*ReadCoilReply_CoilValue) Descriptor() ([]byte, []int) {
	return fileDescriptor_modbus_a63a6c6fc050268c, []int{3, 0}
}
func (m *ReadCoilReply_CoilValue) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ReadCoilReply_CoilValue.Unmarshal(m, b)
}
func (m *ReadCoilReply_CoilValue) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ReadCoilReply_CoilValue.Marshal(b, m, deterministic)
}
func (dst *ReadCoilReply_CoilValue) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReadCoilReply_CoilValue.Merge(dst, src)
}
func (m *ReadCoilReply_CoilValue) XXX_Size() int {
	return xxx_messageInfo_ReadCoilReply_CoilValue.Size(m)
}
func (m *ReadCoilReply_CoilValue) XXX_DiscardUnknown() {
	xxx_messageInfo_ReadCoilReply_CoilValue.DiscardUnknown(m)
}

var xxx_messageInfo_ReadCoilReply_CoilValue proto.InternalMessageInfo

func (m *ReadCoilReply_CoilValue) GetAddr() uint32 {
	if m != nil {
		return m.Addr
	}
	return 0
}

func (m *ReadCoilReply_CoilValue) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

type OpenTCPConnectionRequest struct {
	Addr                 string   `protobuf:"bytes,1,opt,name=addr,proto3" json:"addr,omitempty"`
	Port                 int32    `protobuf:"varint,2,opt,name=port,proto3" json:"port,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *OpenTCPConnectionRequest) Reset()         { *m = OpenTCPConnectionRequest{} }
func (m *OpenTCPConnectionRequest) String() string { return proto.CompactTextString(m) }
func (*OpenTCPConnectionRequest) ProtoMessage()    {}
func (*OpenTCPConnectionRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_modbus_a63a6c6fc050268c, []int{4}
}
func (m *OpenTCPConnectionRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_OpenTCPConnectionRequest.Unmarshal(m, b)
}
func (m *OpenTCPConnectionRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_OpenTCPConnectionRequest.Marshal(b, m, deterministic)
}
func (dst *OpenTCPConnectionRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OpenTCPConnectionRequest.Merge(dst, src)
}
func (m *OpenTCPConnectionRequest) XXX_Size() int {
	return xxx_messageInfo_OpenTCPConnectionRequest.Size(m)
}
func (m *OpenTCPConnectionRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_OpenTCPConnectionRequest.DiscardUnknown(m)
}

var xxx_messageInfo_OpenTCPConnectionRequest proto.InternalMessageInfo

func (m *OpenTCPConnectionRequest) GetAddr() string {
	if m != nil {
		return m.Addr
	}
	return ""
}

func (m *OpenTCPConnectionRequest) GetPort() int32 {
	if m != nil {
		return m.Port
	}
	return 0
}

type OpenSerialConnectionRequest struct {
	Device               string   `protobuf:"bytes,1,opt,name=device,proto3" json:"device,omitempty"`
	Baud                 int32    `protobuf:"varint,2,opt,name=baud,proto3" json:"baud,omitempty"`
	Parity               string   `protobuf:"bytes,3,opt,name=parity,proto3" json:"parity,omitempty"`
	DataBit              int32    `protobuf:"varint,4,opt,name=data_bit,json=dataBit,proto3" json:"data_bit,omitempty"`
	StopBit              int32    `protobuf:"varint,5,opt,name=stop_bit,json=stopBit,proto3" json:"stop_bit,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *OpenSerialConnectionRequest) Reset()         { *m = OpenSerialConnectionRequest{} }
func (m *OpenSerialConnectionRequest) String() string { return proto.CompactTextString(m) }
func (*OpenSerialConnectionRequest) ProtoMessage()    {}
func (*OpenSerialConnectionRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_modbus_a63a6c6fc050268c, []int{5}
}
func (m *OpenSerialConnectionRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_OpenSerialConnectionRequest.Unmarshal(m, b)
}
func (m *OpenSerialConnectionRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_OpenSerialConnectionRequest.Marshal(b, m, deterministic)
}
func (dst *OpenSerialConnectionRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OpenSerialConnectionRequest.Merge(dst, src)
}
func (m *OpenSerialConnectionRequest) XXX_Size() int {
	return xxx_messageInfo_OpenSerialConnectionRequest.Size(m)
}
func (m *OpenSerialConnectionRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_OpenSerialConnectionRequest.DiscardUnknown(m)
}

var xxx_messageInfo_OpenSerialConnectionRequest proto.InternalMessageInfo

func (m *OpenSerialConnectionRequest) GetDevice() string {
	if m != nil {
		return m.Device
	}
	return ""
}

func (m *OpenSerialConnectionRequest) GetBaud() int32 {
	if m != nil {
		return m.Baud
	}
	return 0
}

func (m *OpenSerialConnectionRequest) GetParity() string {
	if m != nil {
		return m.Parity
	}
	return ""
}

func (m *OpenSerialConnectionRequest) GetDataBit() int32 {
	if m != nil {
		return m.DataBit
	}
	return 0
}

func (m *OpenSerialConnectionRequest) GetStopBit() int32 {
	if m != nil {
		return m.StopBit
	}
	return 0
}

type CloseConnectionRequest struct {
	Id                   string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CloseConnectionRequest) Reset()         { *m = CloseConnectionRequest{} }
func (m *CloseConnectionRequest) String() string { return proto.CompactTextString(m) }
func (*CloseConnectionRequest) ProtoMessage()    {}
func (*CloseConnectionRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_modbus_a63a6c6fc050268c, []int{6}
}
func (m *CloseConnectionRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CloseConnectionRequest.Unmarshal(m, b)
}
func (m *CloseConnectionRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CloseConnectionRequest.Marshal(b, m, deterministic)
}
func (dst *CloseConnectionRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CloseConnectionRequest.Merge(dst, src)
}
func (m *CloseConnectionRequest) XXX_Size() int {
	return xxx_messageInfo_CloseConnectionRequest.Size(m)
}
func (m *CloseConnectionRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CloseConnectionRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CloseConnectionRequest proto.InternalMessageInfo

func (m *CloseConnectionRequest) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

type GetConnectionStatusRequest struct {
	Id                   string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetConnectionStatusRequest) Reset()         { *m = GetConnectionStatusRequest{} }
func (m *GetConnectionStatusRequest) String() string { return proto.CompactTextString(m) }
func (*GetConnectionStatusRequest) ProtoMessage()    {}
func (*GetConnectionStatusRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_modbus_a63a6c6fc050268c, []int{7}
}
func (m *GetConnectionStatusRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GetConnectionStatusRequest.Unmarshal(m, b)
}
func (m *GetConnectionStatusRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GetConnectionStatusRequest.Marshal(b, m, deterministic)
}
func (dst *GetConnectionStatusRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetConnectionStatusRequest.Merge(dst, src)
}
func (m *GetConnectionStatusRequest) XXX_Size() int {
	return xxx_messageInfo_GetConnectionStatusRequest.Size(m)
}
func (m *GetConnectionStatusRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetConnectionStatusRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetConnectionStatusRequest proto.InternalMessageInfo

func (m *GetConnectionStatusRequest) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

type ConnectionStatusReply struct {
	Id                   string                       `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Props                map[string]string            `protobuf:"bytes,2,rep,name=props,proto3" json:"props,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Type                 ConnectionStatusReply_Type   `protobuf:"varint,3,opt,name=type,proto3,enum=modbus.ConnectionStatusReply_Type" json:"type,omitempty"`
	Status               ConnectionStatusReply_Status `protobuf:"varint,4,opt,name=status,proto3,enum=modbus.ConnectionStatusReply_Status" json:"status,omitempty"`
	Errmsg               string                       `protobuf:"bytes,5,opt,name=errmsg,proto3" json:"errmsg,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                     `json:"-"`
	XXX_unrecognized     []byte                       `json:"-"`
	XXX_sizecache        int32                        `json:"-"`
}

func (m *ConnectionStatusReply) Reset()         { *m = ConnectionStatusReply{} }
func (m *ConnectionStatusReply) String() string { return proto.CompactTextString(m) }
func (*ConnectionStatusReply) ProtoMessage()    {}
func (*ConnectionStatusReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_modbus_a63a6c6fc050268c, []int{8}
}
func (m *ConnectionStatusReply) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ConnectionStatusReply.Unmarshal(m, b)
}
func (m *ConnectionStatusReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ConnectionStatusReply.Marshal(b, m, deterministic)
}
func (dst *ConnectionStatusReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConnectionStatusReply.Merge(dst, src)
}
func (m *ConnectionStatusReply) XXX_Size() int {
	return xxx_messageInfo_ConnectionStatusReply.Size(m)
}
func (m *ConnectionStatusReply) XXX_DiscardUnknown() {
	xxx_messageInfo_ConnectionStatusReply.DiscardUnknown(m)
}

var xxx_messageInfo_ConnectionStatusReply proto.InternalMessageInfo

func (m *ConnectionStatusReply) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *ConnectionStatusReply) GetProps() map[string]string {
	if m != nil {
		return m.Props
	}
	return nil
}

func (m *ConnectionStatusReply) GetType() ConnectionStatusReply_Type {
	if m != nil {
		return m.Type
	}
	return ConnectionStatusReply_TCP
}

func (m *ConnectionStatusReply) GetStatus() ConnectionStatusReply_Status {
	if m != nil {
		return m.Status
	}
	return ConnectionStatusReply_ERROR
}

func (m *ConnectionStatusReply) GetErrmsg() string {
	if m != nil {
		return m.Errmsg
	}
	return ""
}

func init() {
	proto.RegisterType((*ReadHoldingRegRequest)(nil), "modbus.ReadHoldingRegRequest")
	proto.RegisterType((*ReadHoldingRegReply)(nil), "modbus.ReadHoldingRegReply")
	proto.RegisterType((*ReadHoldingRegReply_HoldingRegisterValue)(nil), "modbus.ReadHoldingRegReply.HoldingRegisterValue")
	proto.RegisterType((*ReadCoilRequest)(nil), "modbus.ReadCoilRequest")
	proto.RegisterType((*ReadCoilReply)(nil), "modbus.ReadCoilReply")
	proto.RegisterType((*ReadCoilReply_CoilValue)(nil), "modbus.ReadCoilReply.CoilValue")
	proto.RegisterType((*OpenTCPConnectionRequest)(nil), "modbus.OpenTCPConnectionRequest")
	proto.RegisterType((*OpenSerialConnectionRequest)(nil), "modbus.OpenSerialConnectionRequest")
	proto.RegisterType((*CloseConnectionRequest)(nil), "modbus.CloseConnectionRequest")
	proto.RegisterType((*GetConnectionStatusRequest)(nil), "modbus.GetConnectionStatusRequest")
	proto.RegisterType((*ConnectionStatusReply)(nil), "modbus.ConnectionStatusReply")
	proto.RegisterMapType((map[string]string)(nil), "modbus.ConnectionStatusReply.PropsEntry")
	proto.RegisterEnum("modbus.ConnectionStatusReply_Type", ConnectionStatusReply_Type_name, ConnectionStatusReply_Type_value)
	proto.RegisterEnum("modbus.ConnectionStatusReply_Status", ConnectionStatusReply_Status_name, ConnectionStatusReply_Status_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// ModbusClient is the client API for Modbus service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type ModbusClient interface {
	ReadHoldingReg(ctx context.Context, in *ReadHoldingRegRequest, opts ...grpc.CallOption) (*ReadHoldingRegReply, error)
	ReadCoil(ctx context.Context, in *ReadCoilRequest, opts ...grpc.CallOption) (*ReadCoilReply, error)
	OpenTCPConnection(ctx context.Context, in *OpenTCPConnectionRequest, opts ...grpc.CallOption) (*ConnectionStatusReply, error)
	OpenSerialConnection(ctx context.Context, in *OpenSerialConnectionRequest, opts ...grpc.CallOption) (*ConnectionStatusReply, error)
	CloseConnection(ctx context.Context, in *CloseConnectionRequest, opts ...grpc.CallOption) (*ConnectionStatusReply, error)
	GetConnectionStatus(ctx context.Context, in *GetConnectionStatusRequest, opts ...grpc.CallOption) (*ConnectionStatusReply, error)
}

type modbusClient struct {
	cc *grpc.ClientConn
}

func NewModbusClient(cc *grpc.ClientConn) ModbusClient {
	return &modbusClient{cc}
}

func (c *modbusClient) ReadHoldingReg(ctx context.Context, in *ReadHoldingRegRequest, opts ...grpc.CallOption) (*ReadHoldingRegReply, error) {
	out := new(ReadHoldingRegReply)
	err := c.cc.Invoke(ctx, "/modbus.Modbus/ReadHoldingReg", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *modbusClient) ReadCoil(ctx context.Context, in *ReadCoilRequest, opts ...grpc.CallOption) (*ReadCoilReply, error) {
	out := new(ReadCoilReply)
	err := c.cc.Invoke(ctx, "/modbus.Modbus/ReadCoil", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *modbusClient) OpenTCPConnection(ctx context.Context, in *OpenTCPConnectionRequest, opts ...grpc.CallOption) (*ConnectionStatusReply, error) {
	out := new(ConnectionStatusReply)
	err := c.cc.Invoke(ctx, "/modbus.Modbus/OpenTCPConnection", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *modbusClient) OpenSerialConnection(ctx context.Context, in *OpenSerialConnectionRequest, opts ...grpc.CallOption) (*ConnectionStatusReply, error) {
	out := new(ConnectionStatusReply)
	err := c.cc.Invoke(ctx, "/modbus.Modbus/OpenSerialConnection", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *modbusClient) CloseConnection(ctx context.Context, in *CloseConnectionRequest, opts ...grpc.CallOption) (*ConnectionStatusReply, error) {
	out := new(ConnectionStatusReply)
	err := c.cc.Invoke(ctx, "/modbus.Modbus/CloseConnection", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *modbusClient) GetConnectionStatus(ctx context.Context, in *GetConnectionStatusRequest, opts ...grpc.CallOption) (*ConnectionStatusReply, error) {
	out := new(ConnectionStatusReply)
	err := c.cc.Invoke(ctx, "/modbus.Modbus/GetConnectionStatus", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ModbusServer is the server API for Modbus service.
type ModbusServer interface {
	ReadHoldingReg(context.Context, *ReadHoldingRegRequest) (*ReadHoldingRegReply, error)
	ReadCoil(context.Context, *ReadCoilRequest) (*ReadCoilReply, error)
	OpenTCPConnection(context.Context, *OpenTCPConnectionRequest) (*ConnectionStatusReply, error)
	OpenSerialConnection(context.Context, *OpenSerialConnectionRequest) (*ConnectionStatusReply, error)
	CloseConnection(context.Context, *CloseConnectionRequest) (*ConnectionStatusReply, error)
	GetConnectionStatus(context.Context, *GetConnectionStatusRequest) (*ConnectionStatusReply, error)
}

func RegisterModbusServer(s *grpc.Server, srv ModbusServer) {
	s.RegisterService(&_Modbus_serviceDesc, srv)
}

func _Modbus_ReadHoldingReg_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReadHoldingRegRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ModbusServer).ReadHoldingReg(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/modbus.Modbus/ReadHoldingReg",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ModbusServer).ReadHoldingReg(ctx, req.(*ReadHoldingRegRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Modbus_ReadCoil_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReadCoilRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ModbusServer).ReadCoil(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/modbus.Modbus/ReadCoil",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ModbusServer).ReadCoil(ctx, req.(*ReadCoilRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Modbus_OpenTCPConnection_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OpenTCPConnectionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ModbusServer).OpenTCPConnection(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/modbus.Modbus/OpenTCPConnection",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ModbusServer).OpenTCPConnection(ctx, req.(*OpenTCPConnectionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Modbus_OpenSerialConnection_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OpenSerialConnectionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ModbusServer).OpenSerialConnection(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/modbus.Modbus/OpenSerialConnection",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ModbusServer).OpenSerialConnection(ctx, req.(*OpenSerialConnectionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Modbus_CloseConnection_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CloseConnectionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ModbusServer).CloseConnection(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/modbus.Modbus/CloseConnection",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ModbusServer).CloseConnection(ctx, req.(*CloseConnectionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Modbus_GetConnectionStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetConnectionStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ModbusServer).GetConnectionStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/modbus.Modbus/GetConnectionStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ModbusServer).GetConnectionStatus(ctx, req.(*GetConnectionStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Modbus_serviceDesc = grpc.ServiceDesc{
	ServiceName: "modbus.Modbus",
	HandlerType: (*ModbusServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ReadHoldingReg",
			Handler:    _Modbus_ReadHoldingReg_Handler,
		},
		{
			MethodName: "ReadCoil",
			Handler:    _Modbus_ReadCoil_Handler,
		},
		{
			MethodName: "OpenTCPConnection",
			Handler:    _Modbus_OpenTCPConnection_Handler,
		},
		{
			MethodName: "OpenSerialConnection",
			Handler:    _Modbus_OpenSerialConnection_Handler,
		},
		{
			MethodName: "CloseConnection",
			Handler:    _Modbus_CloseConnection_Handler,
		},
		{
			MethodName: "GetConnectionStatus",
			Handler:    _Modbus_GetConnectionStatus_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "modbus.proto",
}

func init() { proto.RegisterFile("modbus.proto", fileDescriptor_modbus_a63a6c6fc050268c) }

var fileDescriptor_modbus_a63a6c6fc050268c = []byte{
	// 768 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x55, 0xdd, 0x6e, 0xda, 0x48,
	0x14, 0xc6, 0x18, 0x0c, 0x3e, 0xd9, 0x10, 0x76, 0xf2, 0xb3, 0x2c, 0x6c, 0xb2, 0xc8, 0xbb, 0x17,
	0x5c, 0x54, 0xa8, 0xa2, 0x6a, 0x1b, 0x55, 0x51, 0xd5, 0x04, 0x50, 0x12, 0x35, 0x05, 0x34, 0xa4,
	0xa9, 0x5a, 0x55, 0x42, 0x06, 0x4f, 0xd0, 0xa8, 0xc6, 0x76, 0xed, 0x71, 0x24, 0x5e, 0xa2, 0x17,
	0xb9, 0xe9, 0xa3, 0xf4, 0x61, 0xfa, 0x2a, 0xbd, 0xa8, 0x66, 0x3c, 0xfc, 0x04, 0x0c, 0xa8, 0x52,
	0xef, 0xce, 0xdf, 0xf7, 0xf9, 0xf0, 0x1d, 0x7f, 0x06, 0xfe, 0x18, 0xb9, 0x56, 0x3f, 0x0c, 0xaa,
	0x9e, 0xef, 0x32, 0x17, 0x69, 0x51, 0x66, 0xdc, 0x2b, 0xb0, 0x8f, 0x89, 0x69, 0x5d, 0xb8, 0xb6,
	0x45, 0x9d, 0x21, 0x26, 0x43, 0x4c, 0x3e, 0x87, 0x24, 0x60, 0xe8, 0x10, 0x20, 0xb0, 0xcd, 0x3b,
	0xd2, 0x33, 0x2d, 0xcb, 0x2f, 0x28, 0x65, 0xa5, 0xb2, 0x8d, 0x75, 0x51, 0x39, 0xb5, 0x2c, 0x5f,
	0xb4, 0x99, 0xe9, 0xb3, 0xa8, 0x9d, 0x94, 0x6d, 0x5e, 0x11, 0xed, 0x7f, 0x00, 0x9c, 0x70, 0xd4,
	0x73, 0x6f, 0x7b, 0x3e, 0x19, 0x16, 0x54, 0xd1, 0xce, 0x3a, 0xe1, 0xa8, 0x7d, 0x8b, 0xc9, 0x90,
	0x83, 0x7d, 0x62, 0x5a, 0x3d, 0xea, 0x78, 0x21, 0x2b, 0xa4, 0xca, 0x4a, 0x25, 0x8b, 0x75, 0x5e,
	0xb9, 0xe4, 0x05, 0xe3, 0xbb, 0x02, 0xbb, 0x8b, 0x4b, 0x79, 0xf6, 0x98, 0xc3, 0xfa, 0x63, 0x46,
	0x7a, 0x03, 0x37, 0x74, 0xd8, 0x64, 0x25, 0x5e, 0xa9, 0xf3, 0x02, 0xfa, 0x1b, 0xb2, 0x34, 0x90,
	0x9c, 0x49, 0xc1, 0x99, 0xa1, 0x81, 0x60, 0x44, 0x17, 0xa0, 0xdd, 0x99, 0x76, 0x48, 0x82, 0x82,
	0x5a, 0x56, 0x2b, 0x5b, 0xb5, 0xc7, 0x55, 0xa9, 0x46, 0xcc, 0x63, 0xaa, 0xb3, 0x9c, 0x06, 0x8c,
	0xf8, 0x37, 0x1c, 0x88, 0x25, 0xbe, 0xf8, 0x0a, 0xf6, 0xe2, 0xfa, 0x08, 0x41, 0x6a, 0x4e, 0x28,
	0x11, 0xa3, 0x3d, 0x48, 0x0b, 0x94, 0xd8, 0x46, 0xc7, 0x51, 0x62, 0x7c, 0x51, 0x60, 0x87, 0x3f,
	0xb6, 0xee, 0x52, 0xfb, 0xf7, 0x88, 0x7d, 0x04, 0x5b, 0x52, 0xec, 0x81, 0x4b, 0x6d, 0xa9, 0xb6,
	0x2e, 0xd4, 0xe6, 0x0f, 0xd9, 0x24, 0xf7, 0x37, 0x05, 0xb6, 0x67, 0x0b, 0x71, 0xa1, 0x4b, 0xa0,
	0xf7, 0x29, 0x7b, 0xa0, 0x73, 0xb6, 0x4f, 0xd9, 0x46, 0x99, 0x9f, 0x2f, 0xc8, 0xfc, 0xef, 0xbc,
	0xcc, 0x53, 0xfa, 0x2a, 0x8f, 0x1e, 0xaa, 0xfa, 0x14, 0xf4, 0x69, 0xf1, 0x17, 0xa4, 0x3c, 0x83,
	0x42, 0xdb, 0x23, 0xce, 0x75, 0xbd, 0x53, 0x77, 0x1d, 0x87, 0x0c, 0x18, 0x75, 0x9d, 0x89, 0xa4,
	0xf3, 0x2c, 0xba, 0x64, 0x41, 0x90, 0xf2, 0x5c, 0x3f, 0x5a, 0x3b, 0x8d, 0x45, 0x6c, 0x7c, 0x55,
	0xa0, 0xc4, 0x49, 0xba, 0xc4, 0xa7, 0xa6, 0xbd, 0xcc, 0x73, 0x00, 0x9a, 0x45, 0xee, 0xe8, 0x80,
	0x48, 0x26, 0x99, 0x71, 0xae, 0xbe, 0x19, 0x5a, 0x13, 0x2e, 0x1e, 0xf3, 0x59, 0xcf, 0xf4, 0x29,
	0x1b, 0x8b, 0x1b, 0xe8, 0x58, 0x66, 0x5c, 0x32, 0xcb, 0x64, 0x66, 0xaf, 0x4f, 0x23, 0xf9, 0xd3,
	0x38, 0xc3, 0xf3, 0x33, 0x2a, 0xd4, 0x0c, 0x98, 0xeb, 0x89, 0x56, 0x3a, 0x6a, 0xf1, 0xfc, 0x8c,
	0x32, 0xa3, 0x02, 0x07, 0x75, 0xdb, 0x0d, 0xc8, 0xf2, 0x4e, 0x39, 0x48, 0x52, 0x4b, 0xee, 0x93,
	0xa4, 0x96, 0xf1, 0x08, 0x8a, 0xe7, 0x84, 0xcd, 0xe6, 0xba, 0xcc, 0x64, 0x61, 0xb0, 0x6a, 0xfa,
	0x5e, 0x85, 0xfd, 0xe5, 0x59, 0x7e, 0xf7, 0x85, 0x49, 0xf4, 0x12, 0xd2, 0x9e, 0xef, 0x7a, 0x41,
	0x21, 0x29, 0xce, 0x59, 0x99, 0x9c, 0x33, 0x16, 0x5d, 0xed, 0xf0, 0xd1, 0xa6, 0xc3, 0xfc, 0x31,
	0x8e, 0x60, 0xe8, 0x19, 0xa4, 0xd8, 0xd8, 0x23, 0x42, 0x8d, 0x5c, 0xcd, 0x58, 0x0f, 0xbf, 0x1e,
	0x7b, 0x04, 0x8b, 0x79, 0x74, 0x02, 0x5a, 0x20, 0x3a, 0x42, 0xad, 0x5c, 0xed, 0xff, 0xf5, 0x48,
	0x19, 0x4b, 0x0c, 0xbf, 0x02, 0xf1, 0xfd, 0x51, 0x30, 0x14, 0x82, 0xea, 0x58, 0x66, 0xc5, 0x63,
	0x80, 0xd9, 0x8a, 0x28, 0x0f, 0xea, 0x27, 0x32, 0x96, 0x3f, 0x96, 0x87, 0xf1, 0xef, 0xd8, 0x8b,
	0xe4, 0xb1, 0x62, 0x94, 0x20, 0xc5, 0xb7, 0x43, 0x19, 0x50, 0xaf, 0xeb, 0x9d, 0x7c, 0x02, 0x01,
	0x68, 0xdd, 0x26, 0xbe, 0x3c, 0xbd, 0xca, 0x2b, 0x46, 0x03, 0xb4, 0x68, 0x01, 0xa4, 0x43, 0xba,
	0x89, 0x71, 0x1b, 0x47, 0x03, 0xf5, 0xab, 0x76, 0xb7, 0xd9, 0xc8, 0x2b, 0x68, 0x0b, 0x32, 0x9d,
	0x66, 0xab, 0x71, 0xd9, 0x3a, 0xcf, 0x27, 0x79, 0xf2, 0xb6, 0xf5, 0xba, 0xd5, 0x7e, 0xd7, 0xca,
	0xab, 0x1c, 0x80, 0x9b, 0xa7, 0x8d, 0xf7, 0xf9, 0x54, 0xed, 0x87, 0x0a, 0xda, 0x1b, 0xf1, 0x23,
	0x51, 0x0b, 0x72, 0x0f, 0x3f, 0x4b, 0xe8, 0x70, 0xd5, 0xe7, 0x4a, 0x1c, 0xb8, 0x58, 0x5a, 0xf3,
	0x35, 0x33, 0x12, 0xe8, 0x04, 0xb2, 0x13, 0xff, 0xa1, 0xbf, 0x96, 0x1d, 0x19, 0x71, 0xec, 0xc7,
	0x5a, 0xd5, 0x48, 0xa0, 0x1b, 0xf8, 0x73, 0xc9, 0x63, 0xa8, 0x3c, 0x99, 0x5e, 0x65, 0xbf, 0xe2,
	0xe1, 0xda, 0x93, 0x19, 0x09, 0xf4, 0x11, 0xf6, 0xe2, 0x6c, 0x87, 0xfe, 0x9b, 0xa7, 0x5e, 0x61,
	0xca, 0xcd, 0xec, 0x18, 0x76, 0x16, 0xbc, 0x83, 0x8e, 0xa6, 0x98, 0x58, 0x53, 0x6d, 0xe6, 0xfc,
	0x00, 0xbb, 0x31, 0x2e, 0x43, 0xd3, 0xd7, 0x7a, 0xb5, 0x05, 0x37, 0x72, 0xf7, 0x35, 0xf1, 0xb7,
	0xfc, 0xe4, 0x67, 0x00, 0x00, 0x00, 0xff, 0xff, 0xdc, 0xef, 0xc0, 0xa1, 0xa6, 0x07, 0x00, 0x00,
}
