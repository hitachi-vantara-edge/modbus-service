// GNU LESSER GENERAL PUBLIC LICENSE Version 2.1, February 1999

// WARNING: This file has automatically been generated on Wed, 19 Sep 2018 15:16:06 PDT.
// Code generated by https://git.io/c-for-go. DO NOT EDIT.

package libmodbus

/*
#cgo LDFLAGS: -lmodbus
#include "config.h"
#include "modbus.h"
#include "modbus-private.h"
#include "modbus-rtu.h"
#include "modbus-rtu-private.h"
#include "modbus-tcp.h"
#include "modbus-tcp-private.h"
#include "modbus-version.h"
#include "errno.h"
#include "stdio.h"
#include "stdlib.h"
#include <stdlib.h>
#include "cgo_helpers.h"
static inline const char * get_error() {
	return modbus_strerror(errno);
}
*/
import "C"
import (
	"runtime"
	"sync"
	"unsafe"
)

// Ref returns a reference to C object as it is.
func (x *T) Ref() *C.modbus_t {
	if x == nil {
		return nil
	}
	return (*C.modbus_t)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *T) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTRef converts the C object reference into a raw struct reference without wrapping.
func NewTRef(ref unsafe.Pointer) *T {
	return (*T)(ref)
}

// NewT allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewT() *T {
	return (*T)(allocTMemory(1))
}

// allocTMemory allocates memory for type C.modbus_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfTValue = unsafe.Sizeof([1]C.modbus_t{})

// cgoAllocMap stores pointers to C allocated memory for future reference.
type cgoAllocMap struct {
	mux sync.RWMutex
	m   map[unsafe.Pointer]struct{}
}

var cgoAllocsUnknown = new(cgoAllocMap)

func (a *cgoAllocMap) Add(ptr unsafe.Pointer) {
	a.mux.Lock()
	if a.m == nil {
		a.m = make(map[unsafe.Pointer]struct{})
	}
	a.m[ptr] = struct{}{}
	a.mux.Unlock()
}

func (a *cgoAllocMap) IsEmpty() bool {
	a.mux.RLock()
	isEmpty := len(a.m) == 0
	a.mux.RUnlock()
	return isEmpty
}

func (a *cgoAllocMap) Borrow(b *cgoAllocMap) {
	if b == nil || b.IsEmpty() {
		return
	}
	b.mux.Lock()
	a.mux.Lock()
	for ptr := range b.m {
		if a.m == nil {
			a.m = make(map[unsafe.Pointer]struct{})
		}
		a.m[ptr] = struct{}{}
		delete(b.m, ptr)
	}
	a.mux.Unlock()
	b.mux.Unlock()
}

func (a *cgoAllocMap) Free() {
	a.mux.Lock()
	for ptr := range a.m {
		C.free(ptr)
		delete(a.m, ptr)
	}
	a.mux.Unlock()
}

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *T) PassRef() *C.modbus_t {
	if x == nil {
		x = (*T)(allocTMemory(1))
	}
	return (*C.modbus_t)(unsafe.Pointer(x))
}

// allocMappingTMemory allocates memory for type C.modbus_mapping_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocMappingTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfMappingTValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfMappingTValue = unsafe.Sizeof([1]C.modbus_mapping_t{})

type sliceHeader struct {
	Data unsafe.Pointer
	Len  int
	Cap  int
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *MappingT) Ref() *C.modbus_mapping_t {
	if x == nil {
		return nil
	}
	return x.ref9cc1d52a
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *MappingT) Free() {
	if x != nil && x.allocs9cc1d52a != nil {
		x.allocs9cc1d52a.(*cgoAllocMap).Free()
		x.ref9cc1d52a = nil
	}
}

// NewMappingTRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewMappingTRef(ref unsafe.Pointer) *MappingT {
	if ref == nil {
		return nil
	}
	obj := new(MappingT)
	obj.ref9cc1d52a = (*C.modbus_mapping_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *MappingT) PassRef() (*C.modbus_mapping_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref9cc1d52a != nil {
		return x.ref9cc1d52a, nil
	}
	mem9cc1d52a := allocMappingTMemory(1)
	ref9cc1d52a := (*C.modbus_mapping_t)(mem9cc1d52a)
	allocs9cc1d52a := new(cgoAllocMap)
	allocs9cc1d52a.Add(mem9cc1d52a)

	var cnb_bits_allocs *cgoAllocMap
	ref9cc1d52a.nb_bits, cnb_bits_allocs = (C.int)(x.NbBits), cgoAllocsUnknown
	allocs9cc1d52a.Borrow(cnb_bits_allocs)

	var cstart_bits_allocs *cgoAllocMap
	ref9cc1d52a.start_bits, cstart_bits_allocs = (C.int)(x.StartBits), cgoAllocsUnknown
	allocs9cc1d52a.Borrow(cstart_bits_allocs)

	var cnb_input_bits_allocs *cgoAllocMap
	ref9cc1d52a.nb_input_bits, cnb_input_bits_allocs = (C.int)(x.NbInputBits), cgoAllocsUnknown
	allocs9cc1d52a.Borrow(cnb_input_bits_allocs)

	var cstart_input_bits_allocs *cgoAllocMap
	ref9cc1d52a.start_input_bits, cstart_input_bits_allocs = (C.int)(x.StartInputBits), cgoAllocsUnknown
	allocs9cc1d52a.Borrow(cstart_input_bits_allocs)

	var cnb_input_registers_allocs *cgoAllocMap
	ref9cc1d52a.nb_input_registers, cnb_input_registers_allocs = (C.int)(x.NbInputRegisters), cgoAllocsUnknown
	allocs9cc1d52a.Borrow(cnb_input_registers_allocs)

	var cstart_input_registers_allocs *cgoAllocMap
	ref9cc1d52a.start_input_registers, cstart_input_registers_allocs = (C.int)(x.StartInputRegisters), cgoAllocsUnknown
	allocs9cc1d52a.Borrow(cstart_input_registers_allocs)

	var cnb_registers_allocs *cgoAllocMap
	ref9cc1d52a.nb_registers, cnb_registers_allocs = (C.int)(x.NbRegisters), cgoAllocsUnknown
	allocs9cc1d52a.Borrow(cnb_registers_allocs)

	var cstart_registers_allocs *cgoAllocMap
	ref9cc1d52a.start_registers, cstart_registers_allocs = (C.int)(x.StartRegisters), cgoAllocsUnknown
	allocs9cc1d52a.Borrow(cstart_registers_allocs)

	var ctab_bits_allocs *cgoAllocMap
	ref9cc1d52a.tab_bits, ctab_bits_allocs = (*C.uint8_t)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.TabBits)).Data)), cgoAllocsUnknown
	allocs9cc1d52a.Borrow(ctab_bits_allocs)

	var ctab_input_bits_allocs *cgoAllocMap
	ref9cc1d52a.tab_input_bits, ctab_input_bits_allocs = (*C.uint8_t)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.TabInputBits)).Data)), cgoAllocsUnknown
	allocs9cc1d52a.Borrow(ctab_input_bits_allocs)

	var ctab_input_registers_allocs *cgoAllocMap
	ref9cc1d52a.tab_input_registers, ctab_input_registers_allocs = (*C.uint16_t)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.TabInputRegisters)).Data)), cgoAllocsUnknown
	allocs9cc1d52a.Borrow(ctab_input_registers_allocs)

	var ctab_registers_allocs *cgoAllocMap
	ref9cc1d52a.tab_registers, ctab_registers_allocs = (*C.uint16_t)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.TabRegisters)).Data)), cgoAllocsUnknown
	allocs9cc1d52a.Borrow(ctab_registers_allocs)

	x.ref9cc1d52a = ref9cc1d52a
	x.allocs9cc1d52a = allocs9cc1d52a
	return ref9cc1d52a, allocs9cc1d52a

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x MappingT) PassValue() (C.modbus_mapping_t, *cgoAllocMap) {
	if x.ref9cc1d52a != nil {
		return *x.ref9cc1d52a, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *MappingT) Deref() {
	if x.ref9cc1d52a == nil {
		return
	}
	x.NbBits = (int32)(x.ref9cc1d52a.nb_bits)
	x.StartBits = (int32)(x.ref9cc1d52a.start_bits)
	x.NbInputBits = (int32)(x.ref9cc1d52a.nb_input_bits)
	x.StartInputBits = (int32)(x.ref9cc1d52a.start_input_bits)
	x.NbInputRegisters = (int32)(x.ref9cc1d52a.nb_input_registers)
	x.StartInputRegisters = (int32)(x.ref9cc1d52a.start_input_registers)
	x.NbRegisters = (int32)(x.ref9cc1d52a.nb_registers)
	x.StartRegisters = (int32)(x.ref9cc1d52a.start_registers)
	hxfc4425b := (*sliceHeader)(unsafe.Pointer(&x.TabBits))
	hxfc4425b.Data = unsafe.Pointer(x.ref9cc1d52a.tab_bits)
	hxfc4425b.Cap = 0x7fffffff
	// hxfc4425b.Len = ?

	hxf95e7c8 := (*sliceHeader)(unsafe.Pointer(&x.TabInputBits))
	hxf95e7c8.Data = unsafe.Pointer(x.ref9cc1d52a.tab_input_bits)
	hxf95e7c8.Cap = 0x7fffffff
	// hxf95e7c8.Len = ?

	hxff2234b := (*sliceHeader)(unsafe.Pointer(&x.TabInputRegisters))
	hxff2234b.Data = unsafe.Pointer(x.ref9cc1d52a.tab_input_registers)
	hxff2234b.Cap = 0x7fffffff
	// hxff2234b.Len = ?

	hxff73280 := (*sliceHeader)(unsafe.Pointer(&x.TabRegisters))
	hxff73280.Data = unsafe.Pointer(x.ref9cc1d52a.tab_registers)
	hxff73280.Cap = 0x7fffffff
	// hxff73280.Len = ?

}

// packPCharString creates a Go string backed by *C.char and avoids copying.
func packPCharString(p *C.char) (raw string) {
	if p != nil && *p != 0 {
		h := (*stringHeader)(unsafe.Pointer(&raw))
		h.Data = unsafe.Pointer(p)
		for *p != 0 {
			p = (*C.char)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + 1)) // p++
		}
		h.Len = int(uintptr(unsafe.Pointer(p)) - uintptr(h.Data))
	}
	return
}

type stringHeader struct {
	Data unsafe.Pointer
	Len  int
}

// RawString reperesents a string backed by data on the C side.
type RawString string

// Copy returns a Go-managed copy of raw string.
func (raw RawString) Copy() string {
	if len(raw) == 0 {
		return ""
	}
	h := (*stringHeader)(unsafe.Pointer(&raw))
	return C.GoStringN((*C.char)(h.Data), C.int(h.Len))
}

// unpackPUint8TString represents the data from Go string as *C.uint8_t and avoids copying.
func unpackPUint8TString(str string) (*C.uint8_t, *cgoAllocMap) {
	h := (*stringHeader)(unsafe.Pointer(&str))
	return (*C.uint8_t)(h.Data), cgoAllocsUnknown
}

const sizeOfPtr = unsafe.Sizeof(&struct{}{})

// unpackArgSMappingT transforms a sliced Go data structure into plain C format.
func unpackArgSMappingT(x []MappingT) (unpacked *C.modbus_mapping_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.modbus_mapping_t) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocMappingTMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.modbus_mapping_t)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.modbus_mapping_t)(h.Data)
	return
}

// packSMappingT reads sliced Go data structure out from plain C format.
func packSMappingT(v []MappingT, ptr0 *C.modbus_mapping_t) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfMappingTValue]C.modbus_mapping_t)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewMappingTRef(unsafe.Pointer(&ptr1))
	}
}

// unpackPCharString represents the data from Go string as *C.char and avoids copying.
func unpackPCharString(str string) (*C.char, *cgoAllocMap) {
	h := (*stringHeader)(unsafe.Pointer(&str))
	return (*C.char)(h.Data), cgoAllocsUnknown
}

func GetErrnoStr() string {
	__ret := C.get_error()
	__v := packPCharString(__ret)
	return __v
}
